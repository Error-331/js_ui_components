'use strict';

// @flow

// external imports
import type {Node} from 'react';

import React, {useState, useEffect, useRef, useContext} from 'react';
import {createUseStyles, useTheme} from 'react-jss';

import {isNil, defaultTo, addIndex, map, forEach} from 'ramda';
import classNames from 'classnames';

// local imports
import type {ThemeType} from './../../types/theme_types';
import type {StateTypes as ThemContextType} from './../../theming/providers';

import {MainThemeContext} from './../../theming/providers';

import FontIcon from './../layout/icons/font_icon';

// type definitions
export type ControlIconDataType = {
    active?: boolean,
    title?: string,

    iconClassName?: string,

    mouseClickHandler?: (event: SyntheticMouseEvent<HTMLDivElement>) => void,
    mouseDownHandler?: (event: SyntheticMouseEvent<HTMLDivElement>) => void,
};

export type ControlGroupDataType = Array<ControlIconDataType>;
export type ControlSectionDataType = Array<ControlGroupDataType>

type CSSStylesType = {
    [string]: mixed
};

export type FormTextInputTypes = {
    data?: ControlSectionDataType,

    className?: string,
    style?: CSSStylesType,
};

export type GroupFormatDataType = {
    isFirst: boolean,
    isLast?: boolean,
    rowNum: number
};

export type GroupsFormatDataType = Array<GroupFormatDataType>;

type PropsTypes = FormTextInputTypes & {
    /**
     * JSS theme object
     *
     * @ignore
     */

    theme: ThemeType,

    /**
     * JSS inner classes
     *
     * @ignore
     */

    classes: any
};

type StateTypes = {};

// styles definition
const useStyles = createUseStyles(theme => ({
    componentContainer: {
        boxSizing: 'border-box',
        display: 'flex',
        position: 'relative',

        flexDirection: 'column',
        flexWrap: 'nowrap',

        justifyContent: 'flex-start',
        alignItems: 'stretch',
        alignContent: 'flex-start',

        '& > $controlSection': {
            boxSizing: 'border-box',
            display: 'flex',

            flexBasis: 'auto',
            flexShrink: 1,
            flexGrow: 0,

            flexDirection: 'row',
            flexWrap: 'wrap',

            justifyContent: 'flex-start',
            alignItems: 'center',
            alignContent: 'flex-start',

            '& > $controlsGroup': {
                boxSizing: 'border-box',
                display: 'flex',

                flexBasis: 'auto',
                flexShrink: 1,
                flexGrow: 0,

                flexDirection: 'row',
                flexWrap: 'wrap',

                justifyContent: 'flex-start',
                alignItems: 'center',
                alignContent: 'flex-start',

                marginLeft: `${theme.layoutStyles.formHorizontalSpacing}px`,

                '& > $control': {
                    boxSizing: 'border-box',

                    flexBasis: 'auto',
                    flexShrink: 1,
                    flexGrow: 0,

                    marginLeft: `${theme.layoutStyles.sectionHorizontalSpacing}px`,

                    color: theme.inputStyles.inactiveColor,

                    '&.active': {
                        color: theme.inputStyles.activeColor,
                    },

                    '&:hover': {
                        color: theme.inputStyles.hoverColor
                    },

                    '&:first-child': {
                        marginLeft: `0px`,
                    },
                },

                '&.firstGroupInSection': {
                    marginLeft: '0px',
                },

                '&.lastGroupInSection': {
                    marginRight: `${theme.layoutStyles.formHorizontalSpacing}px`,
                },

                '&.noneFirstGroupInRow': {
                    paddingTop: `${theme.layoutStyles.sectionVerticalSpacing}px`,
                }
            },
        },
    },

    controlSection: {},
    controlsGroup: {},
    control: {},
}));

/**
 * Horizontal icon toolbar component styled according to material-UI guidelines.
 * Component is intendent to be used as a toolbar for other components such as.
 *
 * @version 1.0.0
 * @author [Sergei Selihov](https://github.com/Error-331)
 *
 */

// component implementation
function HorizontalIconToolbarComponent(props: PropsTypes) {
    // region private variables declaration
    const data: ControlSectionDataType = defaultTo([], props.data);

    // endregion

    // region style hooks declaration
    const theme: ThemeType = useTheme();
    const classes: {[string]: string} = useStyles({...props, theme});

    // endregion

    // region context hooks declaration
    const themeContext: ThemContextType = useContext(MainThemeContext);

    // endregion

    // region state hooks declaration
    const [sectionsFormatData, setSectionsFormatData] = useState([]);

    // endregion

    // region effect hooks declaration
    useEffect(() => {
        if (isNil($toolbarRef) || isNil($toolbarRef.current)) {
            return;
        }

        const $controlSections: Array<HTMLDivElement> = $toolbarRef.current.children;

        const sectionsFormatData: Array<GroupsFormatDataType> = map(($controlSection: HTMLDivElement) => {
            const controlSectionClientRect: ClientRect = $controlSection.getBoundingClientRect();
            const $controlGroups: Array<HTMLDivElement> = $controlSection.children;

            const sectionWidth: number = controlSectionClientRect.width;
            let totalWidth: number = 0;
            let currentRow: number = 0;

            const groupFormatData: GroupsFormatDataType = [];

            addIndex(forEach)(($controlGroup: HTMLDivElement, controlGroupIndex: number) => {
                const controlGroupClientRect: ClientRect = $controlGroup.getBoundingClientRect();
                const groupWidth: number = controlGroupClientRect.width;

                if (controlGroupIndex === 0) {
                    totalWidth += groupWidth;

                    groupFormatData.push({isFirst: true, rowNum: currentRow});
                } else {
                    const groupWithWithPadding: number = groupWidth + theme.layoutStyles.formHorizontalSpacing;

                    const totalWidthWithPaddedGroup: number = groupWithWithPadding + totalWidth;
                    const totalWidthWithGroup: number = groupWidth + totalWidth;

                    if (totalWidthWithPaddedGroup <= sectionWidth) {
                        totalWidth += groupWithWithPadding;

                        groupFormatData.push({isFirst: false, rowNum: currentRow});
                    } else if (totalWidthWithGroup <= sectionWidth) {
                        totalWidth = groupWidth;
                        currentRow = currentRow + 1;

                        groupFormatData[groupFormatData.length - 1].isLast = true;
                        groupFormatData.push({isFirst: true, rowNum: currentRow});
                    } else {
                        totalWidth = groupWidth;
                        currentRow = currentRow + 1;

                        groupFormatData.push({isFirst: true, rowNum: currentRow});
                    }
                }
            }, $controlGroups);

            return groupFormatData;
        }, $controlSections);

        setSectionsFormatData(sectionsFormatData);
    }, [themeContext.windowDimensions.innerWidth]);

    // endregion

    // region state variables declaration
    // endregion

    // region ref hooks declaration
    const $toolbarRef: any = useRef(null);

    // endregion

    // region callback hooks declaration
    // endregion

    // region business logic
    // endregion

    // region event handler helpers
    // endregion

    // region render helpers
    const renderControls = (controlGroupData: ControlGroupDataType) => {
        return addIndex(map)((controlIconData: ControlIconDataType, index: number) => {
            let {active, iconClassName, mouseClickHandler, mouseDownHandler} = controlIconData;
            const {control} = classes;

            active = defaultTo(false, active);
            mouseClickHandler = defaultTo(() => {}, mouseClickHandler);
            mouseDownHandler = defaultTo(() => {}, mouseDownHandler);

            const className = classNames(control, {active});

            return <FontIcon
                size='small'

                className={className}
                iconClassName={iconClassName}

                onMouseClick={mouseClickHandler}
                onMouseDown={mouseDownHandler}

                key={`control_${index}`}
            />;
        }, controlGroupData);
    };

    const renderControlGroups = (controlSectionData: ControlSectionDataType, GroupsFormatData: GroupFormatDataType) => {
        return addIndex(map)((controlGroupData: ControlGroupDataType, index: number) => {
            const groupFormatData: GroupFormatDataType = defaultTo({}, GroupsFormatData[index]);

            const ifFirstOnRow: boolean = defaultTo(false, groupFormatData.isFirst);
            const isLastOnRow: boolean = defaultTo(false, groupFormatData.isLast);
            const rowNum: number = defaultTo(false, groupFormatData.rowNum);

            const {controlsGroup} = classes;

            const className: string = classNames(controlsGroup, {
                firstGroupInSection: ifFirstOnRow,
                lastGroupInSection: isLastOnRow,
                noneFirstGroupInRow: rowNum > 0
            });

            return <div
                className={className}
                key={`group_${index}`}
            >
                {renderControls(controlGroupData)}
            </div>;
        }, controlSectionData);
    };

    const renderControlSections = () => {
        return addIndex(map)((controlSectionData: ControlSectionDataType, index: number) => {
            const groupFormatData: GroupsFormatDataType = defaultTo([], sectionsFormatData[index]);
            const {controlSection} = classes;

            return <div
                className={controlSection}
                key={`section_${index}`}
            >
                {renderControlGroups(controlSectionData, groupFormatData)}
            </div>;
        }, data);
    };


    /*

        const renderControlGroup: (children: Node) => Node = (children: Node) => {
        const {controlsGroup} = classes;

        return <div className={controlsGroup}>
            {children}
        </div>;
    };
     */

    const renderComponentContainer = () => {
        const {componentContainer} = classes;

        return <div ref={$toolbarRef} className={componentContainer}>
            {renderControlSections()}
        </div>
    };

    // endregion

    // init
    return renderComponentContainer();
}

// exports
export default HorizontalIconToolbarComponent;
